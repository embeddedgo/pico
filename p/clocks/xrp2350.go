// DO NOT EDIT THIS FILE. GENERATED BY xgen.

//go:build rp2350

package clocks

import (
	"embedded/mmio"
	"unsafe"

	"github.com/embeddedgo/pico/p/mmap"
)

type Periph struct {
	CLK              [10]SCLK
	DFT_XOSC_CTRL    mmio.R32[DFT_OSC_CTRL]
	DFT_ROSC_CTRL    mmio.R32[DFT_OSC_CTRL]
	DFT_LPOSC_CTRL   mmio.R32[DFT_OSC_CTRL]
	SYS_RESUS_CTRL   mmio.R32[SYS_RESUS_CTRL]
	SYS_RESUS_STATUS mmio.R32[uint32]
	FC0_REF_KHZ      mmio.R32[uint32]
	FC0_MIN_KHZ      mmio.R32[uint32]
	FC0_MAX_KHZ      mmio.R32[uint32]
	FC0_DELAY        mmio.R32[uint32]
	FC0_INTERVAL     mmio.R32[uint32]
	FC0_SRC          mmio.R32[FC0_SRC]
	FC0_STATUS       mmio.R32[FC0_STATUS]
	FC0_RESULT       mmio.R32[uint32]
	WAKE_EN0         mmio.R32[CLK0_EN]
	WAKE_EN1         mmio.R32[CLK_EN1]
	SLEEP_EN0        mmio.R32[CLK0_EN]
	SLEEP_EN1        mmio.R32[CLK1_EN]
	ENABLED0         mmio.R32[CLK0_EN]
	ENABLED1         mmio.R32[CLK1_EN]
	INTR             mmio.R32[uint32]
	INTE             mmio.R32[uint32]
	INTF             mmio.R32[uint32]
	INTS             mmio.R32[uint32]
}

func CLOCKS() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.CLOCKS_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type SCLK struct {
	CTRL     mmio.R32[CTRL]
	DIV      mmio.R32[DIV]
	SELECTED mmio.R32[SELECTED]
}

type CTRL uint32

func GPOUT_AUXSRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, GPOUT_AUXSRC}
}
func GPOUT_KILL_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, GPOUT_KILL}
}
func GPOUT_ENABLE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, GPOUT_ENABLE}
}
func GPOUT_DC50_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, GPOUT_DC50}
}
func GPOUT_PHASE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, GPOUT_PHASE}
}
func GPOUT_NUDGE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, GPOUT_NUDGE}
}
func GPOUT_ENABLED_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, GPOUT_ENABLED}
}
func REF_SRC_(p *Periph, i int) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CLK[i].CTRL, REF_SRC} }
func REF_AUXSRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, REF_AUXSRC}
}
func SYS_SRC_(p *Periph, i int) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CLK[i].CTRL, SYS_SRC} }
func SYS_AUXSRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, SYS_AUXSRC}
}
func PERI_AUXSRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, PERI_AUXSRC}
}
func PERI_KILL_(p *Periph, i int) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CLK[i].CTRL, PERI_KILL} }
func PERI_ENABLE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, PERI_ENABLE}
}
func PERI_ENABLED_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, PERI_ENABLED}
}
func HSTX_AUXSRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, HSTX_AUXSRC}
}
func HSTX_KILL_(p *Periph, i int) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CLK[i].CTRL, HSTX_KILL} }
func HSTX_ENABLE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, HSTX_ENABLE}
}
func HSTX_PHASE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, HSTX_PHASE}
}
func HSTX_NUDGE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, HSTX_NUDGE}
}
func HSTX_ENABLED_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, HSTX_ENABLED}
}
func USB_AUXSRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, USB_AUXSRC}
}
func USB_KILL_(p *Periph, i int) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CLK[i].CTRL, USB_KILL} }
func USB_ENABLE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, USB_ENABLE}
}
func USB_PHASE_(p *Periph, i int) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CLK[i].CTRL, USB_PHASE} }
func USB_NUDGE_(p *Periph, i int) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CLK[i].CTRL, USB_NUDGE} }
func USB_ENABLED_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, USB_ENABLED}
}
func ADC_AUXSRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, ADC_AUXSRC}
}
func ADC_KILL_(p *Periph, i int) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CLK[i].CTRL, ADC_KILL} }
func ADC_ENABLE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, ADC_ENABLE}
}
func ADC_PHASE_(p *Periph, i int) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CLK[i].CTRL, ADC_PHASE} }
func ADC_NUDGE_(p *Periph, i int) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{&p.CLK[i].CTRL, ADC_NUDGE} }
func ADC_ENABLED_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{&p.CLK[i].CTRL, ADC_ENABLED}
}

type DIV uint32

func GPOUT_FRAC_(p *Periph, i int) mmio.RM32[DIV] { return mmio.RM32[DIV]{&p.CLK[i].DIV, GPOUT_FRAC} }
func GPOUT_INT_(p *Periph, i int) mmio.RM32[DIV]  { return mmio.RM32[DIV]{&p.CLK[i].DIV, GPOUT_INT} }
func REF_INT_(p *Periph, i int) mmio.RM32[DIV]    { return mmio.RM32[DIV]{&p.CLK[i].DIV, REF_INT} }
func SYS_FRAC_(p *Periph, i int) mmio.RM32[DIV]   { return mmio.RM32[DIV]{&p.CLK[i].DIV, SYS_FRAC} }
func SYS_INT_(p *Periph, i int) mmio.RM32[DIV]    { return mmio.RM32[DIV]{&p.CLK[i].DIV, SYS_INT} }
func PERI_INT_(p *Periph, i int) mmio.RM32[DIV]   { return mmio.RM32[DIV]{&p.CLK[i].DIV, PERI_INT} }
func HSTX_INT_(p *Periph, i int) mmio.RM32[DIV]   { return mmio.RM32[DIV]{&p.CLK[i].DIV, HSTX_INT} }
func USB_INT_(p *Periph, i int) mmio.RM32[DIV]    { return mmio.RM32[DIV]{&p.CLK[i].DIV, USB_INT} }
func ADC_INT_(p *Periph, i int) mmio.RM32[DIV]    { return mmio.RM32[DIV]{&p.CLK[i].DIV, ADC_INT} }

type SELECTED uint32

type DFT_OSC_CTRL uint32

type SYS_RESUS_CTRL uint32

func TIMEOUT_(p *Periph) mmio.RM32[SYS_RESUS_CTRL] {
	return mmio.RM32[SYS_RESUS_CTRL]{&p.SYS_RESUS_CTRL, TIMEOUT}
}
func ENABLE_(p *Periph) mmio.RM32[SYS_RESUS_CTRL] {
	return mmio.RM32[SYS_RESUS_CTRL]{&p.SYS_RESUS_CTRL, ENABLE}
}
func FRCE_(p *Periph) mmio.RM32[SYS_RESUS_CTRL] {
	return mmio.RM32[SYS_RESUS_CTRL]{&p.SYS_RESUS_CTRL, FRCE}
}
func CLEAR_(p *Periph) mmio.RM32[SYS_RESUS_CTRL] {
	return mmio.RM32[SYS_RESUS_CTRL]{&p.SYS_RESUS_CTRL, CLEAR}
}

type FC0_SRC uint32

func FC0_SOURCE_(p *Periph) mmio.RM32[FC0_SRC] { return mmio.RM32[FC0_SRC]{&p.FC0_SRC, FC0_SOURCE} }

type FC0_STATUS uint32

func PASS_(p *Periph) mmio.RM32[FC0_STATUS]    { return mmio.RM32[FC0_STATUS]{&p.FC0_STATUS, PASS} }
func DONE_(p *Periph) mmio.RM32[FC0_STATUS]    { return mmio.RM32[FC0_STATUS]{&p.FC0_STATUS, DONE} }
func RUNNING_(p *Periph) mmio.RM32[FC0_STATUS] { return mmio.RM32[FC0_STATUS]{&p.FC0_STATUS, RUNNING} }
func WAITING_(p *Periph) mmio.RM32[FC0_STATUS] { return mmio.RM32[FC0_STATUS]{&p.FC0_STATUS, WAITING} }
func FAIL_(p *Periph) mmio.RM32[FC0_STATUS]    { return mmio.RM32[FC0_STATUS]{&p.FC0_STATUS, FAIL} }
func SLOW_(p *Periph) mmio.RM32[FC0_STATUS]    { return mmio.RM32[FC0_STATUS]{&p.FC0_STATUS, SLOW} }
func FAST_(p *Periph) mmio.RM32[FC0_STATUS]    { return mmio.RM32[FC0_STATUS]{&p.FC0_STATUS, FAST} }
func DIED_(p *Periph) mmio.RM32[FC0_STATUS]    { return mmio.RM32[FC0_STATUS]{&p.FC0_STATUS, DIED} }

type CLK0_EN uint32

type CLK_EN1 uint32

type CLK1_EN uint32

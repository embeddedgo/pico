// DO NOT EDIT THIS FILE. GENERATED BY svdxgen.

//go:build rp2350

// Package dma provides access to the registers of the DMA peripheral.
//
// Instances:
//
//	DMA  DMA_BASE  -  DMA_IRQ_0,DMA_IRQ_1,DMA_IRQ_2,DMA_IRQ_3  DMA with separate read and write masters
//
// Registers:
//
//	0x000 32  CH0_READ_ADDR              DMA Channel 0 Read Address pointer
//	0x004 32  CH0_WRITE_ADDR             DMA Channel 0 Write Address pointer
//	0x008 32  CH0_TRANS_COUNT            DMA Channel 0 Transfer Count
//	0x00C 32  CH0_CTRL_TRIG              DMA Channel 0 Control and Status
//	0x010 32  CH0_AL1_CTRL               Alias for channel 0 CTRL register
//	0x014 32  CH0_AL1_READ_ADDR          Alias for channel 0 READ_ADDR register
//	0x018 32  CH0_AL1_WRITE_ADDR         Alias for channel 0 WRITE_ADDR register
//	0x01C 32  CH0_AL1_TRANS_COUNT_TRIG   Alias for channel 0 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x020 32  CH0_AL2_CTRL               Alias for channel 0 CTRL register
//	0x024 32  CH0_AL2_TRANS_COUNT        Alias for channel 0 TRANS_COUNT register
//	0x028 32  CH0_AL2_READ_ADDR          Alias for channel 0 READ_ADDR register
//	0x02C 32  CH0_AL2_WRITE_ADDR_TRIG    Alias for channel 0 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x030 32  CH0_AL3_CTRL               Alias for channel 0 CTRL register
//	0x034 32  CH0_AL3_WRITE_ADDR         Alias for channel 0 WRITE_ADDR register
//	0x038 32  CH0_AL3_TRANS_COUNT        Alias for channel 0 TRANS_COUNT register
//	0x03C 32  CH0_AL3_READ_ADDR_TRIG     Alias for channel 0 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x040 32  CH1_READ_ADDR              DMA Channel 1 Read Address pointer
//	0x044 32  CH1_WRITE_ADDR             DMA Channel 1 Write Address pointer
//	0x048 32  CH1_TRANS_COUNT            DMA Channel 1 Transfer Count
//	0x04C 32  CH1_CTRL_TRIG              DMA Channel 1 Control and Status
//	0x050 32  CH1_AL1_CTRL               Alias for channel 1 CTRL register
//	0x054 32  CH1_AL1_READ_ADDR          Alias for channel 1 READ_ADDR register
//	0x058 32  CH1_AL1_WRITE_ADDR         Alias for channel 1 WRITE_ADDR register
//	0x05C 32  CH1_AL1_TRANS_COUNT_TRIG   Alias for channel 1 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x060 32  CH1_AL2_CTRL               Alias for channel 1 CTRL register
//	0x064 32  CH1_AL2_TRANS_COUNT        Alias for channel 1 TRANS_COUNT register
//	0x068 32  CH1_AL2_READ_ADDR          Alias for channel 1 READ_ADDR register
//	0x06C 32  CH1_AL2_WRITE_ADDR_TRIG    Alias for channel 1 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x070 32  CH1_AL3_CTRL               Alias for channel 1 CTRL register
//	0x074 32  CH1_AL3_WRITE_ADDR         Alias for channel 1 WRITE_ADDR register
//	0x078 32  CH1_AL3_TRANS_COUNT        Alias for channel 1 TRANS_COUNT register
//	0x07C 32  CH1_AL3_READ_ADDR_TRIG     Alias for channel 1 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x080 32  CH2_READ_ADDR              DMA Channel 2 Read Address pointer
//	0x084 32  CH2_WRITE_ADDR             DMA Channel 2 Write Address pointer
//	0x088 32  CH2_TRANS_COUNT            DMA Channel 2 Transfer Count
//	0x08C 32  CH2_CTRL_TRIG              DMA Channel 2 Control and Status
//	0x090 32  CH2_AL1_CTRL               Alias for channel 2 CTRL register
//	0x094 32  CH2_AL1_READ_ADDR          Alias for channel 2 READ_ADDR register
//	0x098 32  CH2_AL1_WRITE_ADDR         Alias for channel 2 WRITE_ADDR register
//	0x09C 32  CH2_AL1_TRANS_COUNT_TRIG   Alias for channel 2 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x0A0 32  CH2_AL2_CTRL               Alias for channel 2 CTRL register
//	0x0A4 32  CH2_AL2_TRANS_COUNT        Alias for channel 2 TRANS_COUNT register
//	0x0A8 32  CH2_AL2_READ_ADDR          Alias for channel 2 READ_ADDR register
//	0x0AC 32  CH2_AL2_WRITE_ADDR_TRIG    Alias for channel 2 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x0B0 32  CH2_AL3_CTRL               Alias for channel 2 CTRL register
//	0x0B4 32  CH2_AL3_WRITE_ADDR         Alias for channel 2 WRITE_ADDR register
//	0x0B8 32  CH2_AL3_TRANS_COUNT        Alias for channel 2 TRANS_COUNT register
//	0x0BC 32  CH2_AL3_READ_ADDR_TRIG     Alias for channel 2 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x0C0 32  CH3_READ_ADDR              DMA Channel 3 Read Address pointer
//	0x0C4 32  CH3_WRITE_ADDR             DMA Channel 3 Write Address pointer
//	0x0C8 32  CH3_TRANS_COUNT            DMA Channel 3 Transfer Count
//	0x0CC 32  CH3_CTRL_TRIG              DMA Channel 3 Control and Status
//	0x0D0 32  CH3_AL1_CTRL               Alias for channel 3 CTRL register
//	0x0D4 32  CH3_AL1_READ_ADDR          Alias for channel 3 READ_ADDR register
//	0x0D8 32  CH3_AL1_WRITE_ADDR         Alias for channel 3 WRITE_ADDR register
//	0x0DC 32  CH3_AL1_TRANS_COUNT_TRIG   Alias for channel 3 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x0E0 32  CH3_AL2_CTRL               Alias for channel 3 CTRL register
//	0x0E4 32  CH3_AL2_TRANS_COUNT        Alias for channel 3 TRANS_COUNT register
//	0x0E8 32  CH3_AL2_READ_ADDR          Alias for channel 3 READ_ADDR register
//	0x0EC 32  CH3_AL2_WRITE_ADDR_TRIG    Alias for channel 3 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x0F0 32  CH3_AL3_CTRL               Alias for channel 3 CTRL register
//	0x0F4 32  CH3_AL3_WRITE_ADDR         Alias for channel 3 WRITE_ADDR register
//	0x0F8 32  CH3_AL3_TRANS_COUNT        Alias for channel 3 TRANS_COUNT register
//	0x0FC 32  CH3_AL3_READ_ADDR_TRIG     Alias for channel 3 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x100 32  CH4_READ_ADDR              DMA Channel 4 Read Address pointer
//	0x104 32  CH4_WRITE_ADDR             DMA Channel 4 Write Address pointer
//	0x108 32  CH4_TRANS_COUNT            DMA Channel 4 Transfer Count
//	0x10C 32  CH4_CTRL_TRIG              DMA Channel 4 Control and Status
//	0x110 32  CH4_AL1_CTRL               Alias for channel 4 CTRL register
//	0x114 32  CH4_AL1_READ_ADDR          Alias for channel 4 READ_ADDR register
//	0x118 32  CH4_AL1_WRITE_ADDR         Alias for channel 4 WRITE_ADDR register
//	0x11C 32  CH4_AL1_TRANS_COUNT_TRIG   Alias for channel 4 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x120 32  CH4_AL2_CTRL               Alias for channel 4 CTRL register
//	0x124 32  CH4_AL2_TRANS_COUNT        Alias for channel 4 TRANS_COUNT register
//	0x128 32  CH4_AL2_READ_ADDR          Alias for channel 4 READ_ADDR register
//	0x12C 32  CH4_AL2_WRITE_ADDR_TRIG    Alias for channel 4 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x130 32  CH4_AL3_CTRL               Alias for channel 4 CTRL register
//	0x134 32  CH4_AL3_WRITE_ADDR         Alias for channel 4 WRITE_ADDR register
//	0x138 32  CH4_AL3_TRANS_COUNT        Alias for channel 4 TRANS_COUNT register
//	0x13C 32  CH4_AL3_READ_ADDR_TRIG     Alias for channel 4 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x140 32  CH5_READ_ADDR              DMA Channel 5 Read Address pointer
//	0x144 32  CH5_WRITE_ADDR             DMA Channel 5 Write Address pointer
//	0x148 32  CH5_TRANS_COUNT            DMA Channel 5 Transfer Count
//	0x14C 32  CH5_CTRL_TRIG              DMA Channel 5 Control and Status
//	0x150 32  CH5_AL1_CTRL               Alias for channel 5 CTRL register
//	0x154 32  CH5_AL1_READ_ADDR          Alias for channel 5 READ_ADDR register
//	0x158 32  CH5_AL1_WRITE_ADDR         Alias for channel 5 WRITE_ADDR register
//	0x15C 32  CH5_AL1_TRANS_COUNT_TRIG   Alias for channel 5 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x160 32  CH5_AL2_CTRL               Alias for channel 5 CTRL register
//	0x164 32  CH5_AL2_TRANS_COUNT        Alias for channel 5 TRANS_COUNT register
//	0x168 32  CH5_AL2_READ_ADDR          Alias for channel 5 READ_ADDR register
//	0x16C 32  CH5_AL2_WRITE_ADDR_TRIG    Alias for channel 5 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x170 32  CH5_AL3_CTRL               Alias for channel 5 CTRL register
//	0x174 32  CH5_AL3_WRITE_ADDR         Alias for channel 5 WRITE_ADDR register
//	0x178 32  CH5_AL3_TRANS_COUNT        Alias for channel 5 TRANS_COUNT register
//	0x17C 32  CH5_AL3_READ_ADDR_TRIG     Alias for channel 5 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x180 32  CH6_READ_ADDR              DMA Channel 6 Read Address pointer
//	0x184 32  CH6_WRITE_ADDR             DMA Channel 6 Write Address pointer
//	0x188 32  CH6_TRANS_COUNT            DMA Channel 6 Transfer Count
//	0x18C 32  CH6_CTRL_TRIG              DMA Channel 6 Control and Status
//	0x190 32  CH6_AL1_CTRL               Alias for channel 6 CTRL register
//	0x194 32  CH6_AL1_READ_ADDR          Alias for channel 6 READ_ADDR register
//	0x198 32  CH6_AL1_WRITE_ADDR         Alias for channel 6 WRITE_ADDR register
//	0x19C 32  CH6_AL1_TRANS_COUNT_TRIG   Alias for channel 6 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x1A0 32  CH6_AL2_CTRL               Alias for channel 6 CTRL register
//	0x1A4 32  CH6_AL2_TRANS_COUNT        Alias for channel 6 TRANS_COUNT register
//	0x1A8 32  CH6_AL2_READ_ADDR          Alias for channel 6 READ_ADDR register
//	0x1AC 32  CH6_AL2_WRITE_ADDR_TRIG    Alias for channel 6 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x1B0 32  CH6_AL3_CTRL               Alias for channel 6 CTRL register
//	0x1B4 32  CH6_AL3_WRITE_ADDR         Alias for channel 6 WRITE_ADDR register
//	0x1B8 32  CH6_AL3_TRANS_COUNT        Alias for channel 6 TRANS_COUNT register
//	0x1BC 32  CH6_AL3_READ_ADDR_TRIG     Alias for channel 6 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x1C0 32  CH7_READ_ADDR              DMA Channel 7 Read Address pointer
//	0x1C4 32  CH7_WRITE_ADDR             DMA Channel 7 Write Address pointer
//	0x1C8 32  CH7_TRANS_COUNT            DMA Channel 7 Transfer Count
//	0x1CC 32  CH7_CTRL_TRIG              DMA Channel 7 Control and Status
//	0x1D0 32  CH7_AL1_CTRL               Alias for channel 7 CTRL register
//	0x1D4 32  CH7_AL1_READ_ADDR          Alias for channel 7 READ_ADDR register
//	0x1D8 32  CH7_AL1_WRITE_ADDR         Alias for channel 7 WRITE_ADDR register
//	0x1DC 32  CH7_AL1_TRANS_COUNT_TRIG   Alias for channel 7 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x1E0 32  CH7_AL2_CTRL               Alias for channel 7 CTRL register
//	0x1E4 32  CH7_AL2_TRANS_COUNT        Alias for channel 7 TRANS_COUNT register
//	0x1E8 32  CH7_AL2_READ_ADDR          Alias for channel 7 READ_ADDR register
//	0x1EC 32  CH7_AL2_WRITE_ADDR_TRIG    Alias for channel 7 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x1F0 32  CH7_AL3_CTRL               Alias for channel 7 CTRL register
//	0x1F4 32  CH7_AL3_WRITE_ADDR         Alias for channel 7 WRITE_ADDR register
//	0x1F8 32  CH7_AL3_TRANS_COUNT        Alias for channel 7 TRANS_COUNT register
//	0x1FC 32  CH7_AL3_READ_ADDR_TRIG     Alias for channel 7 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x200 32  CH8_READ_ADDR              DMA Channel 8 Read Address pointer
//	0x204 32  CH8_WRITE_ADDR             DMA Channel 8 Write Address pointer
//	0x208 32  CH8_TRANS_COUNT            DMA Channel 8 Transfer Count
//	0x20C 32  CH8_CTRL_TRIG              DMA Channel 8 Control and Status
//	0x210 32  CH8_AL1_CTRL               Alias for channel 8 CTRL register
//	0x214 32  CH8_AL1_READ_ADDR          Alias for channel 8 READ_ADDR register
//	0x218 32  CH8_AL1_WRITE_ADDR         Alias for channel 8 WRITE_ADDR register
//	0x21C 32  CH8_AL1_TRANS_COUNT_TRIG   Alias for channel 8 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x220 32  CH8_AL2_CTRL               Alias for channel 8 CTRL register
//	0x224 32  CH8_AL2_TRANS_COUNT        Alias for channel 8 TRANS_COUNT register
//	0x228 32  CH8_AL2_READ_ADDR          Alias for channel 8 READ_ADDR register
//	0x22C 32  CH8_AL2_WRITE_ADDR_TRIG    Alias for channel 8 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x230 32  CH8_AL3_CTRL               Alias for channel 8 CTRL register
//	0x234 32  CH8_AL3_WRITE_ADDR         Alias for channel 8 WRITE_ADDR register
//	0x238 32  CH8_AL3_TRANS_COUNT        Alias for channel 8 TRANS_COUNT register
//	0x23C 32  CH8_AL3_READ_ADDR_TRIG     Alias for channel 8 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x240 32  CH9_READ_ADDR              DMA Channel 9 Read Address pointer
//	0x244 32  CH9_WRITE_ADDR             DMA Channel 9 Write Address pointer
//	0x248 32  CH9_TRANS_COUNT            DMA Channel 9 Transfer Count
//	0x24C 32  CH9_CTRL_TRIG              DMA Channel 9 Control and Status
//	0x250 32  CH9_AL1_CTRL               Alias for channel 9 CTRL register
//	0x254 32  CH9_AL1_READ_ADDR          Alias for channel 9 READ_ADDR register
//	0x258 32  CH9_AL1_WRITE_ADDR         Alias for channel 9 WRITE_ADDR register
//	0x25C 32  CH9_AL1_TRANS_COUNT_TRIG   Alias for channel 9 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x260 32  CH9_AL2_CTRL               Alias for channel 9 CTRL register
//	0x264 32  CH9_AL2_TRANS_COUNT        Alias for channel 9 TRANS_COUNT register
//	0x268 32  CH9_AL2_READ_ADDR          Alias for channel 9 READ_ADDR register
//	0x26C 32  CH9_AL2_WRITE_ADDR_TRIG    Alias for channel 9 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x270 32  CH9_AL3_CTRL               Alias for channel 9 CTRL register
//	0x274 32  CH9_AL3_WRITE_ADDR         Alias for channel 9 WRITE_ADDR register
//	0x278 32  CH9_AL3_TRANS_COUNT        Alias for channel 9 TRANS_COUNT register
//	0x27C 32  CH9_AL3_READ_ADDR_TRIG     Alias for channel 9 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x280 32  CH10_READ_ADDR             DMA Channel 10 Read Address pointer
//	0x284 32  CH10_WRITE_ADDR            DMA Channel 10 Write Address pointer
//	0x288 32  CH10_TRANS_COUNT           DMA Channel 10 Transfer Count
//	0x28C 32  CH10_CTRL_TRIG             DMA Channel 10 Control and Status
//	0x290 32  CH10_AL1_CTRL              Alias for channel 10 CTRL register
//	0x294 32  CH10_AL1_READ_ADDR         Alias for channel 10 READ_ADDR register
//	0x298 32  CH10_AL1_WRITE_ADDR        Alias for channel 10 WRITE_ADDR register
//	0x29C 32  CH10_AL1_TRANS_COUNT_TRIG  Alias for channel 10 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x2A0 32  CH10_AL2_CTRL              Alias for channel 10 CTRL register
//	0x2A4 32  CH10_AL2_TRANS_COUNT       Alias for channel 10 TRANS_COUNT register
//	0x2A8 32  CH10_AL2_READ_ADDR         Alias for channel 10 READ_ADDR register
//	0x2AC 32  CH10_AL2_WRITE_ADDR_TRIG   Alias for channel 10 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x2B0 32  CH10_AL3_CTRL              Alias for channel 10 CTRL register
//	0x2B4 32  CH10_AL3_WRITE_ADDR        Alias for channel 10 WRITE_ADDR register
//	0x2B8 32  CH10_AL3_TRANS_COUNT       Alias for channel 10 TRANS_COUNT register
//	0x2BC 32  CH10_AL3_READ_ADDR_TRIG    Alias for channel 10 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x2C0 32  CH11_READ_ADDR             DMA Channel 11 Read Address pointer
//	0x2C4 32  CH11_WRITE_ADDR            DMA Channel 11 Write Address pointer
//	0x2C8 32  CH11_TRANS_COUNT           DMA Channel 11 Transfer Count
//	0x2CC 32  CH11_CTRL_TRIG             DMA Channel 11 Control and Status
//	0x2D0 32  CH11_AL1_CTRL              Alias for channel 11 CTRL register
//	0x2D4 32  CH11_AL1_READ_ADDR         Alias for channel 11 READ_ADDR register
//	0x2D8 32  CH11_AL1_WRITE_ADDR        Alias for channel 11 WRITE_ADDR register
//	0x2DC 32  CH11_AL1_TRANS_COUNT_TRIG  Alias for channel 11 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x2E0 32  CH11_AL2_CTRL              Alias for channel 11 CTRL register
//	0x2E4 32  CH11_AL2_TRANS_COUNT       Alias for channel 11 TRANS_COUNT register
//	0x2E8 32  CH11_AL2_READ_ADDR         Alias for channel 11 READ_ADDR register
//	0x2EC 32  CH11_AL2_WRITE_ADDR_TRIG   Alias for channel 11 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x2F0 32  CH11_AL3_CTRL              Alias for channel 11 CTRL register
//	0x2F4 32  CH11_AL3_WRITE_ADDR        Alias for channel 11 WRITE_ADDR register
//	0x2F8 32  CH11_AL3_TRANS_COUNT       Alias for channel 11 TRANS_COUNT register
//	0x2FC 32  CH11_AL3_READ_ADDR_TRIG    Alias for channel 11 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x300 32  CH12_READ_ADDR             DMA Channel 12 Read Address pointer
//	0x304 32  CH12_WRITE_ADDR            DMA Channel 12 Write Address pointer
//	0x308 32  CH12_TRANS_COUNT           DMA Channel 12 Transfer Count
//	0x30C 32  CH12_CTRL_TRIG             DMA Channel 12 Control and Status
//	0x310 32  CH12_AL1_CTRL              Alias for channel 12 CTRL register
//	0x314 32  CH12_AL1_READ_ADDR         Alias for channel 12 READ_ADDR register
//	0x318 32  CH12_AL1_WRITE_ADDR        Alias for channel 12 WRITE_ADDR register
//	0x31C 32  CH12_AL1_TRANS_COUNT_TRIG  Alias for channel 12 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x320 32  CH12_AL2_CTRL              Alias for channel 12 CTRL register
//	0x324 32  CH12_AL2_TRANS_COUNT       Alias for channel 12 TRANS_COUNT register
//	0x328 32  CH12_AL2_READ_ADDR         Alias for channel 12 READ_ADDR register
//	0x32C 32  CH12_AL2_WRITE_ADDR_TRIG   Alias for channel 12 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x330 32  CH12_AL3_CTRL              Alias for channel 12 CTRL register
//	0x334 32  CH12_AL3_WRITE_ADDR        Alias for channel 12 WRITE_ADDR register
//	0x338 32  CH12_AL3_TRANS_COUNT       Alias for channel 12 TRANS_COUNT register
//	0x33C 32  CH12_AL3_READ_ADDR_TRIG    Alias for channel 12 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x340 32  CH13_READ_ADDR             DMA Channel 13 Read Address pointer
//	0x344 32  CH13_WRITE_ADDR            DMA Channel 13 Write Address pointer
//	0x348 32  CH13_TRANS_COUNT           DMA Channel 13 Transfer Count
//	0x34C 32  CH13_CTRL_TRIG             DMA Channel 13 Control and Status
//	0x350 32  CH13_AL1_CTRL              Alias for channel 13 CTRL register
//	0x354 32  CH13_AL1_READ_ADDR         Alias for channel 13 READ_ADDR register
//	0x358 32  CH13_AL1_WRITE_ADDR        Alias for channel 13 WRITE_ADDR register
//	0x35C 32  CH13_AL1_TRANS_COUNT_TRIG  Alias for channel 13 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x360 32  CH13_AL2_CTRL              Alias for channel 13 CTRL register
//	0x364 32  CH13_AL2_TRANS_COUNT       Alias for channel 13 TRANS_COUNT register
//	0x368 32  CH13_AL2_READ_ADDR         Alias for channel 13 READ_ADDR register
//	0x36C 32  CH13_AL2_WRITE_ADDR_TRIG   Alias for channel 13 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x370 32  CH13_AL3_CTRL              Alias for channel 13 CTRL register
//	0x374 32  CH13_AL3_WRITE_ADDR        Alias for channel 13 WRITE_ADDR register
//	0x378 32  CH13_AL3_TRANS_COUNT       Alias for channel 13 TRANS_COUNT register
//	0x37C 32  CH13_AL3_READ_ADDR_TRIG    Alias for channel 13 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x380 32  CH14_READ_ADDR             DMA Channel 14 Read Address pointer
//	0x384 32  CH14_WRITE_ADDR            DMA Channel 14 Write Address pointer
//	0x388 32  CH14_TRANS_COUNT           DMA Channel 14 Transfer Count
//	0x38C 32  CH14_CTRL_TRIG             DMA Channel 14 Control and Status
//	0x390 32  CH14_AL1_CTRL              Alias for channel 14 CTRL register
//	0x394 32  CH14_AL1_READ_ADDR         Alias for channel 14 READ_ADDR register
//	0x398 32  CH14_AL1_WRITE_ADDR        Alias for channel 14 WRITE_ADDR register
//	0x39C 32  CH14_AL1_TRANS_COUNT_TRIG  Alias for channel 14 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x3A0 32  CH14_AL2_CTRL              Alias for channel 14 CTRL register
//	0x3A4 32  CH14_AL2_TRANS_COUNT       Alias for channel 14 TRANS_COUNT register
//	0x3A8 32  CH14_AL2_READ_ADDR         Alias for channel 14 READ_ADDR register
//	0x3AC 32  CH14_AL2_WRITE_ADDR_TRIG   Alias for channel 14 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x3B0 32  CH14_AL3_CTRL              Alias for channel 14 CTRL register
//	0x3B4 32  CH14_AL3_WRITE_ADDR        Alias for channel 14 WRITE_ADDR register
//	0x3B8 32  CH14_AL3_TRANS_COUNT       Alias for channel 14 TRANS_COUNT register
//	0x3BC 32  CH14_AL3_READ_ADDR_TRIG    Alias for channel 14 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x3C0 32  CH15_READ_ADDR             DMA Channel 15 Read Address pointer
//	0x3C4 32  CH15_WRITE_ADDR            DMA Channel 15 Write Address pointer
//	0x3C8 32  CH15_TRANS_COUNT           DMA Channel 15 Transfer Count
//	0x3CC 32  CH15_CTRL_TRIG             DMA Channel 15 Control and Status
//	0x3D0 32  CH15_AL1_CTRL              Alias for channel 15 CTRL register
//	0x3D4 32  CH15_AL1_READ_ADDR         Alias for channel 15 READ_ADDR register
//	0x3D8 32  CH15_AL1_WRITE_ADDR        Alias for channel 15 WRITE_ADDR register
//	0x3DC 32  CH15_AL1_TRANS_COUNT_TRIG  Alias for channel 15 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x3E0 32  CH15_AL2_CTRL              Alias for channel 15 CTRL register
//	0x3E4 32  CH15_AL2_TRANS_COUNT       Alias for channel 15 TRANS_COUNT register
//	0x3E8 32  CH15_AL2_READ_ADDR         Alias for channel 15 READ_ADDR register
//	0x3EC 32  CH15_AL2_WRITE_ADDR_TRIG   Alias for channel 15 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x3F0 32  CH15_AL3_CTRL              Alias for channel 15 CTRL register
//	0x3F4 32  CH15_AL3_WRITE_ADDR        Alias for channel 15 WRITE_ADDR register
//	0x3F8 32  CH15_AL3_TRANS_COUNT       Alias for channel 15 TRANS_COUNT register
//	0x3FC 32  CH15_AL3_READ_ADDR_TRIG    Alias for channel 15 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
//	0x400 32  INTR                       Interrupt Status (raw)
//	0x404 32  INTE0                      Interrupt Enables for IRQ 0
//	0x408 32  INTF0                      Force Interrupts
//	0x40C 32  INTS0                      Interrupt Status for IRQ 0
//	0x410 32  INTR1                      Interrupt Status (raw)
//	0x414 32  INTE1                      Interrupt Enables for IRQ 1
//	0x418 32  INTF1                      Force Interrupts
//	0x41C 32  INTS1                      Interrupt Status for IRQ 1
//	0x420 32  INTR2                      Interrupt Status (raw)
//	0x424 32  INTE2                      Interrupt Enables for IRQ 2
//	0x428 32  INTF2                      Force Interrupts
//	0x42C 32  INTS2                      Interrupt Status for IRQ 2
//	0x430 32  INTR3                      Interrupt Status (raw)
//	0x434 32  INTE3                      Interrupt Enables for IRQ 3
//	0x438 32  INTF3                      Force Interrupts
//	0x43C 32  INTS3                      Interrupt Status for IRQ 3
//	0x440 32  TIMER0                     Pacing (X/Y) fractional timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
//	0x444 32  TIMER1                     Pacing (X/Y) fractional timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
//	0x448 32  TIMER2                     Pacing (X/Y) fractional timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
//	0x44C 32  TIMER3                     Pacing (X/Y) fractional timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
//	0x450 32  MULTI_CHAN_TRIGGER         Trigger one or more channels simultaneously
//	0x454 32  SNIFF_CTRL                 Sniffer Control
//	0x458 32  SNIFF_DATA                 Data accumulator for sniff hardware
//	0x460 32  FIFO_LEVELS                Debug RAF, WAF, TDF levels
//	0x464 32  CHAN_ABORT                 Abort an in-progress transfer sequence on one or more channels
//	0x468 32  N_CHANNELS                 The number of channels this DMA instance is equipped with. This DMA supports up to 16 hardware channels, but can be configured with as few as one, to minimise silicon area.
//	0x480 32  SECCFG_CH0                 Security configuration for channel 0. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x484 32  SECCFG_CH1                 Security configuration for channel 1. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x488 32  SECCFG_CH2                 Security configuration for channel 2. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x48C 32  SECCFG_CH3                 Security configuration for channel 3. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x490 32  SECCFG_CH4                 Security configuration for channel 4. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x494 32  SECCFG_CH5                 Security configuration for channel 5. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x498 32  SECCFG_CH6                 Security configuration for channel 6. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x49C 32  SECCFG_CH7                 Security configuration for channel 7. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x4A0 32  SECCFG_CH8                 Security configuration for channel 8. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x4A4 32  SECCFG_CH9                 Security configuration for channel 9. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x4A8 32  SECCFG_CH10                Security configuration for channel 10. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x4AC 32  SECCFG_CH11                Security configuration for channel 11. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x4B0 32  SECCFG_CH12                Security configuration for channel 12. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x4B4 32  SECCFG_CH13                Security configuration for channel 13. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x4B8 32  SECCFG_CH14                Security configuration for channel 14. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x4BC 32  SECCFG_CH15                Security configuration for channel 15. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x4C0 32  SECCFG_IRQ0                Security configuration for IRQ 0. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags.
//	0x4C4 32  SECCFG_IRQ1                Security configuration for IRQ 1. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags.
//	0x4C8 32  SECCFG_IRQ2                Security configuration for IRQ 2. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags.
//	0x4CC 32  SECCFG_IRQ3                Security configuration for IRQ 3. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags.
//	0x4D0 32  SECCFG_MISC                Miscellaneous security configuration
//	0x500 32  MPU_CTRL                   Control register for DMA MPU. Accessible only from a Privileged context.
//	0x504 32  MPU_BAR0                   Base address register for MPU region 0. Writable only from a Secure, Privileged context.
//	0x508 32  MPU_LAR0                   Limit address register for MPU region 0. Writable only from a Secure, Privileged context, with the exception of the P bit.
//	0x50C 32  MPU_BAR1                   Base address register for MPU region 1. Writable only from a Secure, Privileged context.
//	0x510 32  MPU_LAR1                   Limit address register for MPU region 1. Writable only from a Secure, Privileged context, with the exception of the P bit.
//	0x514 32  MPU_BAR2                   Base address register for MPU region 2. Writable only from a Secure, Privileged context.
//	0x518 32  MPU_LAR2                   Limit address register for MPU region 2. Writable only from a Secure, Privileged context, with the exception of the P bit.
//	0x51C 32  MPU_BAR3                   Base address register for MPU region 3. Writable only from a Secure, Privileged context.
//	0x520 32  MPU_LAR3                   Limit address register for MPU region 3. Writable only from a Secure, Privileged context, with the exception of the P bit.
//	0x524 32  MPU_BAR4                   Base address register for MPU region 4. Writable only from a Secure, Privileged context.
//	0x528 32  MPU_LAR4                   Limit address register for MPU region 4. Writable only from a Secure, Privileged context, with the exception of the P bit.
//	0x52C 32  MPU_BAR5                   Base address register for MPU region 5. Writable only from a Secure, Privileged context.
//	0x530 32  MPU_LAR5                   Limit address register for MPU region 5. Writable only from a Secure, Privileged context, with the exception of the P bit.
//	0x534 32  MPU_BAR6                   Base address register for MPU region 6. Writable only from a Secure, Privileged context.
//	0x538 32  MPU_LAR6                   Limit address register for MPU region 6. Writable only from a Secure, Privileged context, with the exception of the P bit.
//	0x53C 32  MPU_BAR7                   Base address register for MPU region 7. Writable only from a Secure, Privileged context.
//	0x540 32  MPU_LAR7                   Limit address register for MPU region 7. Writable only from a Secure, Privileged context, with the exception of the P bit.
//	0x800 32  CH0_DBG_CTDREQ             Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0x804 32  CH0_DBG_TCR                Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0x840 32  CH1_DBG_CTDREQ             Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0x844 32  CH1_DBG_TCR                Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0x880 32  CH2_DBG_CTDREQ             Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0x884 32  CH2_DBG_TCR                Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0x8C0 32  CH3_DBG_CTDREQ             Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0x8C4 32  CH3_DBG_TCR                Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0x900 32  CH4_DBG_CTDREQ             Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0x904 32  CH4_DBG_TCR                Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0x940 32  CH5_DBG_CTDREQ             Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0x944 32  CH5_DBG_TCR                Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0x980 32  CH6_DBG_CTDREQ             Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0x984 32  CH6_DBG_TCR                Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0x9C0 32  CH7_DBG_CTDREQ             Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0x9C4 32  CH7_DBG_TCR                Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0xA00 32  CH8_DBG_CTDREQ             Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0xA04 32  CH8_DBG_TCR                Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0xA40 32  CH9_DBG_CTDREQ             Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0xA44 32  CH9_DBG_TCR                Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0xA80 32  CH10_DBG_CTDREQ            Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0xA84 32  CH10_DBG_TCR               Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0xAC0 32  CH11_DBG_CTDREQ            Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0xAC4 32  CH11_DBG_TCR               Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0xB00 32  CH12_DBG_CTDREQ            Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0xB04 32  CH12_DBG_TCR               Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0xB40 32  CH13_DBG_CTDREQ            Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0xB44 32  CH13_DBG_TCR               Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0xB80 32  CH14_DBG_CTDREQ            Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0xB84 32  CH14_DBG_TCR               Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//	0xBC0 32  CH15_DBG_CTDREQ            Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
//	0xBC4 32  CH15_DBG_TCR               Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package dma

const (
	COUNT        CH0_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH0_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH0_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH0_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH0_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH0_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH0_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH0_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH0_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH0_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH0_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH0_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH0_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH0_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH0_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH0_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH0_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH0_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH0_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH0_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH0_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH0_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH0_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH0_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH0_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH0_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH0_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH0_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH0_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH0_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH0_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH0_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH0_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH0_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH0_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH0_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH0_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH0_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH0_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH0_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH0_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH0_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH0_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH0_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH0_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH0_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH0_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH0_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH0_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH0_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH0_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH0_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH0_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH0_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH0_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH0_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH0_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH0_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH0_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH0_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH0_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH0_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH0_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH0_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH0_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH0_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH0_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH0_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH0_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH0_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH0_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH0_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH0_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH0_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH0_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH0_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH0_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH0_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH0_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH0_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH0_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH0_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH0_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH0_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH0_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH0_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH0_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH1_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH1_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH1_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH1_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH1_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH1_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH1_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH1_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH1_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH1_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH1_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH1_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH1_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH1_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH1_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH1_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH1_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH1_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH1_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH1_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH1_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH1_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH1_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH1_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH1_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH1_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH1_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH1_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH1_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH1_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH1_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH1_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH1_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH1_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH1_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH1_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH1_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH1_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH1_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH1_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH1_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH1_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH1_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH1_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH1_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH1_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH1_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH1_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH1_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH1_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH1_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH1_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH1_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH1_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH1_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH1_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH1_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH1_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH1_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH1_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH1_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH1_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH1_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH1_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH1_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH1_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH1_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH1_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH1_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH1_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH1_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH1_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH1_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH1_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH1_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH1_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH1_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH1_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH1_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH1_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH1_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH1_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH1_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH1_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH1_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH1_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH1_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH2_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH2_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH2_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH2_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH2_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH2_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH2_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH2_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH2_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH2_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH2_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH2_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH2_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH2_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH2_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH2_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH2_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH2_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH2_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH2_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH2_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH2_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH2_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH2_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH2_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH2_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH2_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH2_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH2_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH2_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH2_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH2_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH2_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH2_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH2_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH2_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH2_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH2_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH2_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH2_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH2_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH2_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH2_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH2_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH2_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH2_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH2_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH2_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH2_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH2_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH2_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH2_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH2_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH2_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH2_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH2_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH2_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH2_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH2_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH2_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH2_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH2_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH2_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH2_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH2_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH2_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH2_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH2_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH2_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH2_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH2_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH2_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH2_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH2_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH2_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH2_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH2_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH2_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH2_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH2_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH2_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH2_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH2_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH2_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH2_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH2_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH2_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH3_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH3_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH3_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH3_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH3_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH3_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH3_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH3_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH3_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH3_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH3_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH3_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH3_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH3_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH3_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH3_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH3_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH3_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH3_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH3_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH3_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH3_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH3_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH3_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH3_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH3_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH3_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH3_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH3_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH3_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH3_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH3_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH3_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH3_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH3_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH3_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH3_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH3_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH3_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH3_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH3_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH3_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH3_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH3_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH3_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH3_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH3_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH3_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH3_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH3_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH3_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH3_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH3_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH3_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH3_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH3_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH3_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH3_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH3_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH3_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH3_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH3_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH3_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH3_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH3_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH3_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH3_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH3_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH3_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH3_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH3_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH3_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH3_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH3_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH3_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH3_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH3_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH3_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH3_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH3_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH3_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH3_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH3_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH3_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH3_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH3_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH3_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH4_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH4_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH4_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH4_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH4_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH4_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH4_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH4_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH4_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH4_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH4_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH4_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH4_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH4_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH4_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH4_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH4_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH4_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH4_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH4_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH4_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH4_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH4_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH4_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH4_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH4_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH4_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH4_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH4_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH4_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH4_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH4_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH4_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH4_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH4_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH4_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH4_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH4_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH4_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH4_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH4_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH4_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH4_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH4_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH4_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH4_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH4_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH4_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH4_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH4_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH4_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH4_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH4_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH4_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH4_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH4_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH4_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH4_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH4_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH4_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH4_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH4_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH4_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH4_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH4_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH4_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH4_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH4_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH4_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH4_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH4_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH4_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH4_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH4_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH4_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH4_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH4_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH4_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH4_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH4_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH4_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH4_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH4_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH4_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH4_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH4_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH4_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH5_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH5_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH5_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH5_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH5_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH5_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH5_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH5_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH5_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH5_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH5_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH5_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH5_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH5_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH5_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH5_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH5_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH5_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH5_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH5_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH5_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH5_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH5_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH5_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH5_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH5_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH5_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH5_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH5_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH5_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH5_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH5_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH5_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH5_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH5_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH5_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH5_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH5_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH5_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH5_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH5_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH5_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH5_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH5_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH5_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH5_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH5_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH5_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH5_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH5_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH5_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH5_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH5_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH5_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH5_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH5_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH5_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH5_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH5_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH5_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH5_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH5_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH5_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH5_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH5_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH5_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH5_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH5_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH5_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH5_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH5_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH5_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH5_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH5_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH5_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH5_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH5_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH5_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH5_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH5_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH5_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH5_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH5_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH5_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH5_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH5_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH5_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH6_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH6_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH6_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH6_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH6_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH6_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH6_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH6_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH6_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH6_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH6_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH6_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH6_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH6_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH6_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH6_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH6_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH6_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH6_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH6_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH6_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH6_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH6_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH6_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH6_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH6_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH6_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH6_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH6_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH6_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH6_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH6_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH6_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH6_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH6_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH6_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH6_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH6_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH6_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH6_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH6_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH6_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH6_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH6_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH6_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH6_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH6_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH6_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH6_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH6_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH6_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH6_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH6_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH6_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH6_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH6_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH6_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH6_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH6_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH6_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH6_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH6_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH6_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH6_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH6_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH6_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH6_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH6_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH6_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH6_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH6_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH6_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH6_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH6_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH6_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH6_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH6_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH6_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH6_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH6_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH6_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH6_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH6_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH6_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH6_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH6_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH6_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH7_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH7_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH7_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH7_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH7_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH7_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH7_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH7_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH7_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH7_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH7_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH7_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH7_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH7_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH7_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH7_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH7_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH7_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH7_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH7_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH7_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH7_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH7_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH7_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH7_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH7_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH7_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH7_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH7_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH7_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH7_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH7_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH7_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH7_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH7_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH7_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH7_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH7_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH7_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH7_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH7_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH7_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH7_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH7_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH7_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH7_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH7_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH7_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH7_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH7_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH7_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH7_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH7_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH7_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH7_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH7_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH7_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH7_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH7_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH7_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH7_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH7_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH7_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH7_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH7_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH7_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH7_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH7_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH7_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH7_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH7_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH7_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH7_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH7_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH7_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH7_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH7_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH7_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH7_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH7_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH7_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH7_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH7_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH7_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH7_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH7_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH7_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH8_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH8_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH8_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH8_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH8_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH8_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH8_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH8_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH8_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH8_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH8_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH8_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH8_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH8_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH8_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH8_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH8_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH8_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH8_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH8_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH8_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH8_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH8_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH8_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH8_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH8_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH8_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH8_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH8_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH8_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH8_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH8_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH8_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH8_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH8_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH8_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH8_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH8_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH8_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH8_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH8_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH8_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH8_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH8_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH8_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH8_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH8_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH8_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH8_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH8_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH8_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH8_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH8_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH8_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH8_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH8_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH8_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH8_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH8_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH8_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH8_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH8_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH8_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH8_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH8_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH8_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH8_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH8_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH8_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH8_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH8_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH8_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH8_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH8_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH8_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH8_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH8_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH8_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH8_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH8_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH8_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH8_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH8_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH8_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH8_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH8_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH8_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH9_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH9_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH9_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH9_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH9_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH9_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH9_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH9_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH9_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH9_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH9_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH9_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH9_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH9_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH9_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH9_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH9_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH9_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH9_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH9_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH9_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH9_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH9_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH9_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH9_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH9_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH9_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH9_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH9_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH9_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH9_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH9_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH9_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH9_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH9_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH9_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH9_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH9_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH9_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH9_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH9_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH9_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH9_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH9_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH9_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH9_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH9_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH9_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH9_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH9_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH9_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH9_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH9_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH9_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH9_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH9_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH9_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH9_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH9_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH9_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH9_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH9_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH9_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH9_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH9_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH9_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH9_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH9_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH9_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH9_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH9_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH9_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH9_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH9_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH9_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH9_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH9_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH9_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH9_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH9_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH9_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH9_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH9_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH9_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH9_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH9_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH9_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH10_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH10_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH10_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH10_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH10_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH10_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH10_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH10_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH10_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH10_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH10_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH10_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH10_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH10_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH10_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH10_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH10_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH10_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH10_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH10_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH10_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH10_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH10_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH10_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH10_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH10_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH10_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH10_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH10_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH10_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH10_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH10_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH10_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH10_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH10_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH10_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH10_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH10_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH10_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH10_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH10_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH10_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH10_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH10_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH10_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH10_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH10_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH10_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH10_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH10_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH10_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH10_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH10_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH10_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH10_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH10_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH10_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH10_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH10_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH10_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH10_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH10_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH10_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH10_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH10_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH10_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH10_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH10_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH10_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH10_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH10_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH10_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH10_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH10_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH10_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH10_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH10_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH10_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH10_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH10_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH10_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH10_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH10_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH10_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH10_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH10_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH10_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH11_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH11_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH11_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH11_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH11_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH11_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH11_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH11_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH11_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH11_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH11_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH11_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH11_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH11_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH11_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH11_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH11_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH11_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH11_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH11_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH11_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH11_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH11_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH11_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH11_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH11_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH11_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH11_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH11_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH11_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH11_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH11_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH11_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH11_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH11_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH11_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH11_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH11_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH11_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH11_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH11_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH11_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH11_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH11_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH11_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH11_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH11_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH11_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH11_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH11_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH11_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH11_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH11_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH11_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH11_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH11_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH11_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH11_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH11_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH11_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH11_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH11_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH11_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH11_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH11_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH11_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH11_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH11_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH11_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH11_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH11_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH11_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH11_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH11_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH11_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH11_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH11_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH11_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH11_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH11_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH11_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH11_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH11_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH11_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH11_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH11_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH11_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH12_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH12_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH12_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH12_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH12_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH12_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH12_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH12_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH12_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH12_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH12_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH12_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH12_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH12_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH12_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH12_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH12_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH12_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH12_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH12_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH12_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH12_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH12_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH12_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH12_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH12_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH12_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH12_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH12_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH12_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH12_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH12_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH12_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH12_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH12_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH12_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH12_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH12_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH12_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH12_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH12_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH12_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH12_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH12_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH12_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH12_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH12_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH12_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH12_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH12_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH12_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH12_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH12_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH12_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH12_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH12_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH12_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH12_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH12_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH12_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH12_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH12_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH12_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH12_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH12_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH12_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH12_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH12_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH12_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH12_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH12_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH12_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH12_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH12_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH12_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH12_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH12_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH12_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH12_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH12_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH12_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH12_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH12_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH12_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH12_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH12_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH12_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH13_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH13_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH13_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH13_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH13_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH13_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH13_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH13_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH13_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH13_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH13_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH13_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH13_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH13_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH13_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH13_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH13_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH13_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH13_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH13_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH13_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH13_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH13_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH13_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH13_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH13_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH13_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH13_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH13_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH13_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH13_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH13_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH13_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH13_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH13_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH13_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH13_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH13_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH13_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH13_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH13_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH13_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH13_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH13_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH13_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH13_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH13_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH13_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH13_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH13_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH13_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH13_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH13_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH13_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH13_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH13_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH13_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH13_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH13_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH13_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH13_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH13_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH13_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH13_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH13_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH13_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH13_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH13_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH13_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH13_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH13_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH13_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH13_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH13_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH13_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH13_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH13_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH13_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH13_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH13_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH13_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH13_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH13_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH13_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH13_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH13_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH13_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH14_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH14_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH14_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH14_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH14_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH14_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH14_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH14_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH14_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH14_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH14_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH14_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH14_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH14_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH14_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH14_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH14_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH14_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH14_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH14_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH14_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH14_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH14_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH14_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH14_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH14_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH14_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH14_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH14_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH14_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH14_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH14_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH14_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH14_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH14_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH14_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH14_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH14_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH14_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH14_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH14_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH14_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH14_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH14_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH14_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH14_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH14_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH14_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH14_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH14_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH14_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH14_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH14_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH14_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH14_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH14_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH14_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH14_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH14_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH14_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH14_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH14_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH14_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH14_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH14_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH14_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH14_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH14_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH14_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH14_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH14_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH14_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH14_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH14_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH14_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH14_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH14_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH14_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH14_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH14_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH14_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH14_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH14_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH14_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH14_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH14_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH14_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	COUNT        CH15_TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         CH15_TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       CH15_TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF CH15_TRANS_COUNT = 0x01 << 28
	ENDLESS      CH15_TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CH15_CTRL_TRIG = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CH15_CTRL_TRIG = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CH15_CTRL_TRIG = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CH15_CTRL_TRIG = 0x00 << 2
	SIZE_HALFWORD  CH15_CTRL_TRIG = 0x01 << 2
	SIZE_WORD      CH15_CTRL_TRIG = 0x02 << 2
	INCR_READ      CH15_CTRL_TRIG = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CH15_CTRL_TRIG = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CH15_CTRL_TRIG = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CH15_CTRL_TRIG = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CH15_CTRL_TRIG = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CH15_CTRL_TRIG = 0x00 << 8
	RING_SEL       CH15_CTRL_TRIG = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CH15_CTRL_TRIG = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CH15_CTRL_TRIG = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CH15_CTRL_TRIG = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CH15_CTRL_TRIG = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CH15_CTRL_TRIG = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CH15_CTRL_TRIG = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CH15_CTRL_TRIG = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CH15_CTRL_TRIG = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CH15_CTRL_TRIG = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CH15_CTRL_TRIG = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CH15_CTRL_TRIG = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CH15_CTRL_TRIG = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CH15_CTRL_TRIG = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CH15_CTRL_TRIG = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CH15_CTRL_TRIG = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CH15_CTRL_TRIG = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CH15_CTRL_TRIG = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CH15_CTRL_TRIG = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CH15_CTRL_TRIG = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CH15_CTRL_TRIG = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CH15_CTRL_TRIG = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CH15_CTRL_TRIG = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CH15_CTRL_TRIG = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CH15_CTRL_TRIG = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CH15_CTRL_TRIG = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CH15_CTRL_TRIG = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CH15_CTRL_TRIG = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CH15_CTRL_TRIG = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CH15_CTRL_TRIG = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CH15_CTRL_TRIG = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CH15_CTRL_TRIG = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CH15_CTRL_TRIG = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CH15_CTRL_TRIG = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CH15_CTRL_TRIG = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CH15_CTRL_TRIG = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CH15_CTRL_TRIG = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CH15_CTRL_TRIG = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CH15_CTRL_TRIG = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CH15_CTRL_TRIG = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CH15_CTRL_TRIG = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CH15_CTRL_TRIG = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CH15_CTRL_TRIG = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CH15_CTRL_TRIG = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CH15_CTRL_TRIG = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CH15_CTRL_TRIG = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CH15_CTRL_TRIG = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CH15_CTRL_TRIG = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CH15_CTRL_TRIG = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CH15_CTRL_TRIG = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CH15_CTRL_TRIG = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CH15_CTRL_TRIG = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CH15_CTRL_TRIG = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CH15_CTRL_TRIG = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CH15_CTRL_TRIG = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CH15_CTRL_TRIG = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CH15_CTRL_TRIG = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CH15_CTRL_TRIG = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CH15_CTRL_TRIG = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CH15_CTRL_TRIG = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CH15_CTRL_TRIG = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CH15_CTRL_TRIG = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CH15_CTRL_TRIG = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CH15_CTRL_TRIG = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CH15_CTRL_TRIG = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CH15_CTRL_TRIG = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CH15_CTRL_TRIG = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CH15_CTRL_TRIG = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CH15_CTRL_TRIG = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CH15_CTRL_TRIG = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	Y TIMER0 = 0xFFFF << 0  //+ Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
	X TIMER0 = 0xFFFF << 16 //+ Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
)

const (
	Yn = 0
	Xn = 16
)

const (
	Y TIMER1 = 0xFFFF << 0  //+ Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
	X TIMER1 = 0xFFFF << 16 //+ Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
)

const (
	Yn = 0
	Xn = 16
)

const (
	Y TIMER2 = 0xFFFF << 0  //+ Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
	X TIMER2 = 0xFFFF << 16 //+ Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
)

const (
	Yn = 0
	Xn = 16
)

const (
	Y TIMER3 = 0xFFFF << 0  //+ Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
	X TIMER3 = 0xFFFF << 16 //+ Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
)

const (
	Yn = 0
	Xn = 16
)

const (
	EN      SNIFF_CTRL = 0x01 << 0  //+ Enable sniffer
	DMACH   SNIFF_CTRL = 0x0F << 1  //+ DMA channel for Sniffer to observe
	CALC    SNIFF_CTRL = 0x0F << 5  //+
	CRC32   SNIFF_CTRL = 0x00 << 5  //  Calculate a CRC-32 (IEEE802.3 polynomial)
	CRC32R  SNIFF_CTRL = 0x01 << 5  //  Calculate a CRC-32 (IEEE802.3 polynomial) with bit reversed data
	CRC16   SNIFF_CTRL = 0x02 << 5  //  Calculate a CRC-16-CCITT
	CRC16R  SNIFF_CTRL = 0x03 << 5  //  Calculate a CRC-16-CCITT with bit reversed data
	EVEN    SNIFF_CTRL = 0x0E << 5  //  XOR reduction over all data. == 1 if the total 1 population count is odd.
	SUM     SNIFF_CTRL = 0x0F << 5  //  Calculate a simple 32-bit checksum (addition with a 32 bit accumulator)
	BSWAP   SNIFF_CTRL = 0x01 << 9  //+ Locally perform a byte reverse on the sniffed data, before feeding into checksum. Note that the sniff hardware is downstream of the DMA channel byteswap performed in the read master: if channel CTRL_BSWAP and SNIFF_CTRL_BSWAP are both enabled, their effects cancel from the sniffer's point of view.
	OUT_REV SNIFF_CTRL = 0x01 << 10 //+ If set, the result appears bit-reversed when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus.
	OUT_INV SNIFF_CTRL = 0x01 << 11 //+ If set, the result appears inverted (bitwise complement) when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus.
)

const (
	ENn      = 0
	DMACHn   = 1
	CALCn    = 5
	BSWAPn   = 9
	OUT_REVn = 10
	OUT_INVn = 11
)

const (
	TDF_LVL FIFO_LEVELS = 0xFF << 0  //+ Current Transfer-Data-FIFO fill level
	WAF_LVL FIFO_LEVELS = 0xFF << 8  //+ Current Write-Address-FIFO fill level
	RAF_LVL FIFO_LEVELS = 0xFF << 16 //+ Current Read-Address-FIFO fill level
)

const (
	TDF_LVLn = 0
	WAF_LVLn = 8
	RAF_LVLn = 16
)

const (
	P    SECCFG_CH0 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH0 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH0 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH1 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH1 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH1 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH2 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH2 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH2 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH3 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH3 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH3 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH4 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH4 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH4 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH5 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH5 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH5 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH6 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH6 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH6 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH7 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH7 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH7 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH8 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH8 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH8 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH9 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH9 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH9 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH10 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH10 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH10 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH11 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH11 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH11 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH12 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH12 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH12 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH13 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH13 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH13 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH14 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH14 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH14 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P    SECCFG_CH15 = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	S    SECCFG_CH15 = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK SECCFG_CH15 = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	Pn    = 0
	Sn    = 1
	LOCKn = 2
)

const (
	P SECCFG_IRQ0 = 0x01 << 0 //+ Privileged IRQ. If 1, this IRQ's control registers can only be accessed from a Privileged context. If 0, this IRQ's control registers can be accessed from an Unprivileged context, but Privileged channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Privileged channels.
	S SECCFG_IRQ0 = 0x01 << 1 //+ Secure IRQ. If 1, this IRQ's control registers can only be accessed from a Secure context. If 0, this IRQ's control registers can be accessed from a Non-secure context, but Secure channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Secure channels.
)

const (
	Pn = 0
	Sn = 1
)

const (
	P SECCFG_IRQ1 = 0x01 << 0 //+ Privileged IRQ. If 1, this IRQ's control registers can only be accessed from a Privileged context. If 0, this IRQ's control registers can be accessed from an Unprivileged context, but Privileged channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Privileged channels.
	S SECCFG_IRQ1 = 0x01 << 1 //+ Secure IRQ. If 1, this IRQ's control registers can only be accessed from a Secure context. If 0, this IRQ's control registers can be accessed from a Non-secure context, but Secure channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Secure channels.
)

const (
	Pn = 0
	Sn = 1
)

const (
	P SECCFG_IRQ2 = 0x01 << 0 //+ Privileged IRQ. If 1, this IRQ's control registers can only be accessed from a Privileged context. If 0, this IRQ's control registers can be accessed from an Unprivileged context, but Privileged channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Privileged channels.
	S SECCFG_IRQ2 = 0x01 << 1 //+ Secure IRQ. If 1, this IRQ's control registers can only be accessed from a Secure context. If 0, this IRQ's control registers can be accessed from a Non-secure context, but Secure channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Secure channels.
)

const (
	Pn = 0
	Sn = 1
)

const (
	P SECCFG_IRQ3 = 0x01 << 0 //+ Privileged IRQ. If 1, this IRQ's control registers can only be accessed from a Privileged context. If 0, this IRQ's control registers can be accessed from an Unprivileged context, but Privileged channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Privileged channels.
	S SECCFG_IRQ3 = 0x01 << 1 //+ Secure IRQ. If 1, this IRQ's control registers can only be accessed from a Secure context. If 0, this IRQ's control registers can be accessed from a Non-secure context, but Secure channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Secure channels.
)

const (
	Pn = 0
	Sn = 1
)

const (
	SNIFF_P  SECCFG_MISC = 0x01 << 0 //+ If 1, the sniffer can see data transfers from Privileged channels, and can itself only be accessed from a privileged context, or from a Secure context when SNIFF_S is 0. If 0, the sniffer can be accessed from either a Privileged or Unprivileged context (with sufficient security level) but can not see transfers from Privileged channels.
	SNIFF_S  SECCFG_MISC = 0x01 << 1 //+ If 1, the sniffer can see data transfers from Secure channels, and can itself only be accessed from a Secure context. If 0, the sniffer can be accessed from either a Secure or Non-secure context, but can not see data transfers of Secure channels.
	TIMER0_P SECCFG_MISC = 0x01 << 2 //+ If 1, the TIMER0 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 0 is only visible to Privileged (or more Secure) channels.
	TIMER0_S SECCFG_MISC = 0x01 << 3 //+ If 1, the TIMER0 register is only accessible from a Secure context, and timer DREQ 0 is only visible to Secure channels.
	TIMER1_P SECCFG_MISC = 0x01 << 4 //+ If 1, the TIMER1 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 1 is only visible to Privileged (or more Secure) channels.
	TIMER1_S SECCFG_MISC = 0x01 << 5 //+ If 1, the TIMER1 register is only accessible from a Secure context, and timer DREQ 1 is only visible to Secure channels.
	TIMER2_P SECCFG_MISC = 0x01 << 6 //+ If 1, the TIMER2 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 2 is only visible to Privileged (or more Secure) channels.
	TIMER2_S SECCFG_MISC = 0x01 << 7 //+ If 1, the TIMER2 register is only accessible from a Secure context, and timer DREQ 2 is only visible to Secure channels.
	TIMER3_P SECCFG_MISC = 0x01 << 8 //+ If 1, the TIMER3 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 3 is only visible to Privileged (or more Secure) channels.
	TIMER3_S SECCFG_MISC = 0x01 << 9 //+ If 1, the TIMER3 register is only accessible from a Secure context, and timer DREQ 3 is only visible to Secure channels.
)

const (
	SNIFF_Pn  = 0
	SNIFF_Sn  = 1
	TIMER0_Pn = 2
	TIMER0_Sn = 3
	TIMER1_Pn = 4
	TIMER1_Sn = 5
	TIMER2_Pn = 6
	TIMER2_Sn = 7
	TIMER3_Pn = 8
	TIMER3_Sn = 9
)

const (
	P            MPU_CTRL = 0x01 << 1 //+ Determine whether an address not covered by an active MPU region is Privileged (1) or Unprivileged (0)
	S            MPU_CTRL = 0x01 << 2 //+ Determine whether an address not covered by an active MPU region is Secure (1) or Non-secure (0)
	NS_HIDE_ADDR MPU_CTRL = 0x01 << 3 //+ By default, when a region's S bit is clear, Non-secure-Privileged reads can see the region's base address and limit address. Set this bit to make the addresses appear as 0 to Non-secure reads, even when the region is Non-secure, to avoid leaking information about the processor SAU map.
)

const (
	Pn            = 1
	Sn            = 2
	NS_HIDE_ADDRn = 3
)

const (
	ADDR MPU_BAR0 = 0x7FFFFFF << 5 //+ This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ADDRn = 5
)

const (
	EN   MPU_LAR0 = 0x01 << 0      //+ Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
	P    MPU_LAR0 = 0x01 << 1      //+ Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
	S    MPU_LAR0 = 0x01 << 2      //+ Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
	ADDR MPU_LAR0 = 0x7FFFFFF << 5 //+ Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ENn   = 0
	Pn    = 1
	Sn    = 2
	ADDRn = 5
)

const (
	ADDR MPU_BAR1 = 0x7FFFFFF << 5 //+ This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ADDRn = 5
)

const (
	EN   MPU_LAR1 = 0x01 << 0      //+ Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
	P    MPU_LAR1 = 0x01 << 1      //+ Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
	S    MPU_LAR1 = 0x01 << 2      //+ Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
	ADDR MPU_LAR1 = 0x7FFFFFF << 5 //+ Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ENn   = 0
	Pn    = 1
	Sn    = 2
	ADDRn = 5
)

const (
	ADDR MPU_BAR2 = 0x7FFFFFF << 5 //+ This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ADDRn = 5
)

const (
	EN   MPU_LAR2 = 0x01 << 0      //+ Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
	P    MPU_LAR2 = 0x01 << 1      //+ Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
	S    MPU_LAR2 = 0x01 << 2      //+ Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
	ADDR MPU_LAR2 = 0x7FFFFFF << 5 //+ Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ENn   = 0
	Pn    = 1
	Sn    = 2
	ADDRn = 5
)

const (
	ADDR MPU_BAR3 = 0x7FFFFFF << 5 //+ This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ADDRn = 5
)

const (
	EN   MPU_LAR3 = 0x01 << 0      //+ Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
	P    MPU_LAR3 = 0x01 << 1      //+ Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
	S    MPU_LAR3 = 0x01 << 2      //+ Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
	ADDR MPU_LAR3 = 0x7FFFFFF << 5 //+ Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ENn   = 0
	Pn    = 1
	Sn    = 2
	ADDRn = 5
)

const (
	ADDR MPU_BAR4 = 0x7FFFFFF << 5 //+ This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ADDRn = 5
)

const (
	EN   MPU_LAR4 = 0x01 << 0      //+ Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
	P    MPU_LAR4 = 0x01 << 1      //+ Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
	S    MPU_LAR4 = 0x01 << 2      //+ Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
	ADDR MPU_LAR4 = 0x7FFFFFF << 5 //+ Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ENn   = 0
	Pn    = 1
	Sn    = 2
	ADDRn = 5
)

const (
	ADDR MPU_BAR5 = 0x7FFFFFF << 5 //+ This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ADDRn = 5
)

const (
	EN   MPU_LAR5 = 0x01 << 0      //+ Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
	P    MPU_LAR5 = 0x01 << 1      //+ Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
	S    MPU_LAR5 = 0x01 << 2      //+ Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
	ADDR MPU_LAR5 = 0x7FFFFFF << 5 //+ Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ENn   = 0
	Pn    = 1
	Sn    = 2
	ADDRn = 5
)

const (
	ADDR MPU_BAR6 = 0x7FFFFFF << 5 //+ This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ADDRn = 5
)

const (
	EN   MPU_LAR6 = 0x01 << 0      //+ Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
	P    MPU_LAR6 = 0x01 << 1      //+ Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
	S    MPU_LAR6 = 0x01 << 2      //+ Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
	ADDR MPU_LAR6 = 0x7FFFFFF << 5 //+ Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ENn   = 0
	Pn    = 1
	Sn    = 2
	ADDRn = 5
)

const (
	ADDR MPU_BAR7 = 0x7FFFFFF << 5 //+ This MPU region matches addresses where addr[31:5] (the 27 most significant bits) are greater than or equal to BAR_ADDR, and less than or equal to LAR_ADDR. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ADDRn = 5
)

const (
	EN   MPU_LAR7 = 0x01 << 0      //+ Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
	P    MPU_LAR7 = 0x01 << 1      //+ Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
	S    MPU_LAR7 = 0x01 << 2      //+ Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
	ADDR MPU_LAR7 = 0x7FFFFFF << 5 //+ Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	ENn   = 0
	Pn    = 1
	Sn    = 2
	ADDRn = 5
)

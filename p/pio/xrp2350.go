// Code generated by xgen -g; DO NOT EDIT.

//go:build rp2350

package pio

import (
	"embedded/mmio"
	"structs"
	"unsafe"

	"github.com/embeddedgo/pico/p/mmap"
)

type Periph struct {
	_ structs.HostLayout

	CTRL              mmio.R32[CTRL]
	FSTAT             mmio.R32[FSTAT]
	FDEBUG            mmio.R32[FDEBUG]
	FLEVEL            mmio.R32[FLEVEL]
	TXF               [4]mmio.R32[uint32]
	RXF               [4]mmio.R32[uint32]
	_                 [2]uint32
	INPUT_SYNC_BYPASS mmio.R32[uint32]
	DBG_PADOUT        mmio.R32[uint32]
	DBG_PADOE         mmio.R32[uint32]
	DBG_CFGINFO       mmio.R32[DBG_CFGINFO]
	INSTR_MEM         [32]mmio.R32[uint32]
	SM                [4]SSM
	RXF_PUTGET        [4]SRXF_PUTGET
	_                 [12]uint32
	GPIOBASE          mmio.R32[uint32]
	INTR              mmio.R32[INTR]
	IRQ               [2]SIRQ
}

func PIO0() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.PIO0_BASE))) }
func PIO1() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.PIO1_BASE))) }
func PIO2() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.PIO2_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type CTRL uint32

func SM_ENABLE_(p *Periph) mmio.RM32[CTRL]  { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: SM_ENABLE} }
func SM_RESTART_(p *Periph) mmio.RM32[CTRL] { return mmio.RM32[CTRL]{R: &p.CTRL, Mask: SM_RESTART} }
func CLKDIV_RESTART_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: CLKDIV_RESTART}
}
func PREV_PIO_MASK_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: PREV_PIO_MASK}
}
func NEXT_PIO_MASK_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: NEXT_PIO_MASK}
}
func NEXTPREV_SM_ENABLE_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: NEXTPREV_SM_ENABLE}
}
func NEXTPREV_SM_DISABLE_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: NEXTPREV_SM_DISABLE}
}
func NEXTPREV_CLKDIV_RESTART_(p *Periph) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CTRL, Mask: NEXTPREV_CLKDIV_RESTART}
}

type FSTAT uint32

func RXFULL_(p *Periph) mmio.RM32[FSTAT]  { return mmio.RM32[FSTAT]{R: &p.FSTAT, Mask: RXFULL} }
func RXEMPTY_(p *Periph) mmio.RM32[FSTAT] { return mmio.RM32[FSTAT]{R: &p.FSTAT, Mask: RXEMPTY} }
func TXFULL_(p *Periph) mmio.RM32[FSTAT]  { return mmio.RM32[FSTAT]{R: &p.FSTAT, Mask: TXFULL} }
func TXEMPTY_(p *Periph) mmio.RM32[FSTAT] { return mmio.RM32[FSTAT]{R: &p.FSTAT, Mask: TXEMPTY} }

type FDEBUG uint32

func RXSTALL_(p *Periph) mmio.RM32[FDEBUG] { return mmio.RM32[FDEBUG]{R: &p.FDEBUG, Mask: RXSTALL} }
func RXUNDER_(p *Periph) mmio.RM32[FDEBUG] { return mmio.RM32[FDEBUG]{R: &p.FDEBUG, Mask: RXUNDER} }
func TXOVER_(p *Periph) mmio.RM32[FDEBUG]  { return mmio.RM32[FDEBUG]{R: &p.FDEBUG, Mask: TXOVER} }
func TXSTALL_(p *Periph) mmio.RM32[FDEBUG] { return mmio.RM32[FDEBUG]{R: &p.FDEBUG, Mask: TXSTALL} }

type FLEVEL uint32

func TX0_(p *Periph) mmio.RM32[FLEVEL] { return mmio.RM32[FLEVEL]{R: &p.FLEVEL, Mask: TX0} }
func RX0_(p *Periph) mmio.RM32[FLEVEL] { return mmio.RM32[FLEVEL]{R: &p.FLEVEL, Mask: RX0} }
func TX1_(p *Periph) mmio.RM32[FLEVEL] { return mmio.RM32[FLEVEL]{R: &p.FLEVEL, Mask: TX1} }
func RX1_(p *Periph) mmio.RM32[FLEVEL] { return mmio.RM32[FLEVEL]{R: &p.FLEVEL, Mask: RX1} }
func TX2_(p *Periph) mmio.RM32[FLEVEL] { return mmio.RM32[FLEVEL]{R: &p.FLEVEL, Mask: TX2} }
func RX2_(p *Periph) mmio.RM32[FLEVEL] { return mmio.RM32[FLEVEL]{R: &p.FLEVEL, Mask: RX2} }
func TX3_(p *Periph) mmio.RM32[FLEVEL] { return mmio.RM32[FLEVEL]{R: &p.FLEVEL, Mask: TX3} }
func RX3_(p *Periph) mmio.RM32[FLEVEL] { return mmio.RM32[FLEVEL]{R: &p.FLEVEL, Mask: RX3} }

type DBG_CFGINFO uint32

func FIFO_DEPTH_(p *Periph) mmio.RM32[DBG_CFGINFO] {
	return mmio.RM32[DBG_CFGINFO]{R: &p.DBG_CFGINFO, Mask: FIFO_DEPTH}
}
func SM_COUNT_(p *Periph) mmio.RM32[DBG_CFGINFO] {
	return mmio.RM32[DBG_CFGINFO]{R: &p.DBG_CFGINFO, Mask: SM_COUNT}
}
func IMEM_SIZE_(p *Periph) mmio.RM32[DBG_CFGINFO] {
	return mmio.RM32[DBG_CFGINFO]{R: &p.DBG_CFGINFO, Mask: IMEM_SIZE}
}
func VERSION_(p *Periph) mmio.RM32[DBG_CFGINFO] {
	return mmio.RM32[DBG_CFGINFO]{R: &p.DBG_CFGINFO, Mask: VERSION}
}

type SSM struct {
	_ structs.HostLayout

	CLKDIV    mmio.R32[uint32]
	EXECCTRL  mmio.R32[EXECCTRL]
	SHIFTCTRL mmio.R32[SHIFTCTRL]
	ADDR      mmio.R32[uint32]
	INSTR     mmio.R32[uint32]
	PINCTRL   mmio.R32[PINCTRL]
}

type EXECCTRL uint32

func STATUS_N_(p *Periph, i int) mmio.RM32[EXECCTRL] {
	return mmio.RM32[EXECCTRL]{R: &p.SM[i].EXECCTRL, Mask: STATUS_N}
}
func STATUS_SEL_(p *Periph, i int) mmio.RM32[EXECCTRL] {
	return mmio.RM32[EXECCTRL]{R: &p.SM[i].EXECCTRL, Mask: STATUS_SEL}
}
func WRAP_BOTTOM_(p *Periph, i int) mmio.RM32[EXECCTRL] {
	return mmio.RM32[EXECCTRL]{R: &p.SM[i].EXECCTRL, Mask: WRAP_BOTTOM}
}
func WRAP_TOP_(p *Periph, i int) mmio.RM32[EXECCTRL] {
	return mmio.RM32[EXECCTRL]{R: &p.SM[i].EXECCTRL, Mask: WRAP_TOP}
}
func OUT_STICKY_(p *Periph, i int) mmio.RM32[EXECCTRL] {
	return mmio.RM32[EXECCTRL]{R: &p.SM[i].EXECCTRL, Mask: OUT_STICKY}
}
func INLINE_OUT_EN_(p *Periph, i int) mmio.RM32[EXECCTRL] {
	return mmio.RM32[EXECCTRL]{R: &p.SM[i].EXECCTRL, Mask: INLINE_OUT_EN}
}
func OUT_EN_SEL_(p *Periph, i int) mmio.RM32[EXECCTRL] {
	return mmio.RM32[EXECCTRL]{R: &p.SM[i].EXECCTRL, Mask: OUT_EN_SEL}
}
func JMP_PIN_(p *Periph, i int) mmio.RM32[EXECCTRL] {
	return mmio.RM32[EXECCTRL]{R: &p.SM[i].EXECCTRL, Mask: JMP_PIN}
}
func SIDE_PINDIR_(p *Periph, i int) mmio.RM32[EXECCTRL] {
	return mmio.RM32[EXECCTRL]{R: &p.SM[i].EXECCTRL, Mask: SIDE_PINDIR}
}
func SIDE_EN_(p *Periph, i int) mmio.RM32[EXECCTRL] {
	return mmio.RM32[EXECCTRL]{R: &p.SM[i].EXECCTRL, Mask: SIDE_EN}
}
func EXEC_STALLED_(p *Periph, i int) mmio.RM32[EXECCTRL] {
	return mmio.RM32[EXECCTRL]{R: &p.SM[i].EXECCTRL, Mask: EXEC_STALLED}
}

type SHIFTCTRL uint32

func IN_COUNT_(p *Periph, i int) mmio.RM32[SHIFTCTRL] {
	return mmio.RM32[SHIFTCTRL]{R: &p.SM[i].SHIFTCTRL, Mask: IN_COUNT}
}
func FJOIN_RX_GET_(p *Periph, i int) mmio.RM32[SHIFTCTRL] {
	return mmio.RM32[SHIFTCTRL]{R: &p.SM[i].SHIFTCTRL, Mask: FJOIN_RX_GET}
}
func FJOIN_RX_PUT_(p *Periph, i int) mmio.RM32[SHIFTCTRL] {
	return mmio.RM32[SHIFTCTRL]{R: &p.SM[i].SHIFTCTRL, Mask: FJOIN_RX_PUT}
}
func AUTOPUSH_(p *Periph, i int) mmio.RM32[SHIFTCTRL] {
	return mmio.RM32[SHIFTCTRL]{R: &p.SM[i].SHIFTCTRL, Mask: AUTOPUSH}
}
func AUTOPULL_(p *Periph, i int) mmio.RM32[SHIFTCTRL] {
	return mmio.RM32[SHIFTCTRL]{R: &p.SM[i].SHIFTCTRL, Mask: AUTOPULL}
}
func IN_SHIFTDIR_(p *Periph, i int) mmio.RM32[SHIFTCTRL] {
	return mmio.RM32[SHIFTCTRL]{R: &p.SM[i].SHIFTCTRL, Mask: IN_SHIFTDIR}
}
func OUT_SHIFTDIR_(p *Periph, i int) mmio.RM32[SHIFTCTRL] {
	return mmio.RM32[SHIFTCTRL]{R: &p.SM[i].SHIFTCTRL, Mask: OUT_SHIFTDIR}
}
func PUSH_THRESH_(p *Periph, i int) mmio.RM32[SHIFTCTRL] {
	return mmio.RM32[SHIFTCTRL]{R: &p.SM[i].SHIFTCTRL, Mask: PUSH_THRESH}
}
func PULL_THRESH_(p *Periph, i int) mmio.RM32[SHIFTCTRL] {
	return mmio.RM32[SHIFTCTRL]{R: &p.SM[i].SHIFTCTRL, Mask: PULL_THRESH}
}
func FJOIN_TX_(p *Periph, i int) mmio.RM32[SHIFTCTRL] {
	return mmio.RM32[SHIFTCTRL]{R: &p.SM[i].SHIFTCTRL, Mask: FJOIN_TX}
}
func FJOIN_RX_(p *Periph, i int) mmio.RM32[SHIFTCTRL] {
	return mmio.RM32[SHIFTCTRL]{R: &p.SM[i].SHIFTCTRL, Mask: FJOIN_RX}
}

type PINCTRL uint32

func OUT_BASE_(p *Periph, i int) mmio.RM32[PINCTRL] {
	return mmio.RM32[PINCTRL]{R: &p.SM[i].PINCTRL, Mask: OUT_BASE}
}
func SET_BASE_(p *Periph, i int) mmio.RM32[PINCTRL] {
	return mmio.RM32[PINCTRL]{R: &p.SM[i].PINCTRL, Mask: SET_BASE}
}
func SIDESET_BASE_(p *Periph, i int) mmio.RM32[PINCTRL] {
	return mmio.RM32[PINCTRL]{R: &p.SM[i].PINCTRL, Mask: SIDESET_BASE}
}
func IN_BASE_(p *Periph, i int) mmio.RM32[PINCTRL] {
	return mmio.RM32[PINCTRL]{R: &p.SM[i].PINCTRL, Mask: IN_BASE}
}
func OUT_COUNT_(p *Periph, i int) mmio.RM32[PINCTRL] {
	return mmio.RM32[PINCTRL]{R: &p.SM[i].PINCTRL, Mask: OUT_COUNT}
}
func SET_COUNT_(p *Periph, i int) mmio.RM32[PINCTRL] {
	return mmio.RM32[PINCTRL]{R: &p.SM[i].PINCTRL, Mask: SET_COUNT}
}
func SIDESET_COUNT_(p *Periph, i int) mmio.RM32[PINCTRL] {
	return mmio.RM32[PINCTRL]{R: &p.SM[i].PINCTRL, Mask: SIDESET_COUNT}
}

type SRXF_PUTGET struct {
	_ structs.HostLayout

	E [4]mmio.R32[uint32]
}

type INTR uint32

func SM0_RXNEMPTY_(p *Periph) mmio.RM32[INTR] { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM0_RXNEMPTY} }
func SM1_RXNEMPTY_(p *Periph) mmio.RM32[INTR] { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM1_RXNEMPTY} }
func SM2_RXNEMPTY_(p *Periph) mmio.RM32[INTR] { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM2_RXNEMPTY} }
func SM3_RXNEMPTY_(p *Periph) mmio.RM32[INTR] { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM3_RXNEMPTY} }
func SM0_TXNFULL_(p *Periph) mmio.RM32[INTR]  { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM0_TXNFULL} }
func SM1_TXNFULL_(p *Periph) mmio.RM32[INTR]  { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM1_TXNFULL} }
func SM2_TXNFULL_(p *Periph) mmio.RM32[INTR]  { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM2_TXNFULL} }
func SM3_TXNFULL_(p *Periph) mmio.RM32[INTR]  { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM3_TXNFULL} }
func SM0_(p *Periph) mmio.RM32[INTR]          { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM0} }
func SM1_(p *Periph) mmio.RM32[INTR]          { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM1} }
func SM2_(p *Periph) mmio.RM32[INTR]          { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM2} }
func SM3_(p *Periph) mmio.RM32[INTR]          { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM3} }
func SM4_(p *Periph) mmio.RM32[INTR]          { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM4} }
func SM5_(p *Periph) mmio.RM32[INTR]          { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM5} }
func SM6_(p *Periph) mmio.RM32[INTR]          { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM6} }
func SM7_(p *Periph) mmio.RM32[INTR]          { return mmio.RM32[INTR]{R: &p.INTR, Mask: SM7} }

type SIRQ struct {
	_ structs.HostLayout

	E mmio.R32[INTR]
	F mmio.R32[INTR]
	S mmio.R32[INTR]
}
